K : (u : Level) -> (A : Type u) -> (x : A) -> (h : Eq u A x x) -> Eq u (Eq u A x x) (refl u A x) h :=
  u => A => x => h => refl u (Eq u A x x) h;

const : (u : Level) -> (A : Type u) -> A -> A -> A :=
	_ => _ => x => _ => x;

quoteClosureTest : (u : Level) -> (A : Type u) -> (x : A) -> (P : (A -> A) -> Type u) -> P (const u A x) :=
	u => A => test => P => ?;

#Id : (u : Level) -> Type u -> Type u :=
  u => A => A;
#Id.mk : (u : Level) -> (A : Type u) -> A -> Id u A :=
  u => A => x => Eq.elim (lSucc u) u (Type u -> Type u) (A => A) (i => h => i A) x (Id u) (Id.eq u);
#Id.out : (u : Level) -> (A : Type u) -> Id u A -> A :=
  u => A => Eq.elim (lSucc u) u (Type u -> Type u) (A => A) (i => h => i A -> A) (x => x) (Id u) (Id.eq u);
Id.outMk : (u : Level) -> (A : Type u) -> (x : A) -> Eq u A x (Id.out u A (Id.mk u A x)) :=
  u => A => x =>
    Eq.elim (lSucc u) u ((A : Type u) -> Id u A -> A) (A => Eq.elim (lSucc u) u (Type u -> Type u) (A => A) (i => h => i A -> A) (x => x) (Id u) (Id.eq u)) (o => h => Eq u A x (o A (Id.mk u A x)))
      (Eq.elim (lSucc u) u ((A : Type u) -> A -> Id u A) (A => x => Eq.elim (lSucc u) u (Type u -> Type u) (A => A) (i => h => i A) x (Id u) (Id.eq u)) (m => h => Eq u A x (Eq.elim (lSucc u) u (Type u -> Type u) (A => A) (i => h => i A -> A) (x => x) (Id u) (Id.eq u) (m A x)))
        (Eq.elim (lSucc u) u (Type u -> Type u) (A => A) (i => h => Eq u A x (Eq.elim (lSucc u) u (Type u -> Type u) (A => A) (i => h => i A -> A) (x => x) i h (Eq.elim (lSucc u) u (Type u -> Type u) (A => A) (i => h => i A) x i h))) (refl u A x) (Id u) (Id.eq u))
      (Id.mk u) (Id.mk.eq u))
    (Id.out u) (Id.out.eq u);

fst : (u : Level) -> (v : Level) -> (A : Type u) -> (B : A -> Type v) -> Sigma u v A B -> A :=
  u => v => A => B => Sigma.elim u v u A B (_ => A) (x => _ => x);
snd : (u : Level) -> (v : Level) -> (A : Type u) -> (B : A -> Type v) -> (x : Sigma u v A B) -> B (fst u v A B x) :=
  u => v => A => B => Sigma.elim u v v A B (x => B (fst u v A B x)) (_ => y => y);
Sigma.eta : (u : Level) -> (v : Level) -> (A : Type u) -> (B : A -> Type v) -> (x : Sigma u v A B) -> Eq (lMax u v) (Sigma u v A B) x (pair u v A B (fst u v A B x) (snd u v A B x)) :=
  u => v => A => B => Sigma.elim u v (lMax u v) A B (x => Eq (lMax u v) (Sigma u v A B) x (pair u v A B (fst u v A B x) (snd u v A B x))) (x => y => refl (lMax u v) (Sigma u v A B) (pair u v A B x y));

absurd : (u : Level) -> (v : Level) -> (A : Type v) -> Empty u -> A :=
  u => v => A => Empty.elim u v (_ => A);

Unit.isProp : (u : Level) -> (x : Unit u) -> (y : Unit u) -> Eq u (Unit u) x y :=
  u => x => y => refl u (Unit u) (star u);

trueNeFalse : (u : Level) -> (v : Level) -> Eq u (Bool u) (true u) (false u) -> Empty v :=
  u => v => Eq.elim u v (Bool u) (true u) (b => _ => Bool.elim u (lSucc v) (_ => Type v) (Unit v) (Empty v) b) (star v) (false u);

IsFalse : (u : Level) -> Bool u -> Type u :=
  u => Bool.elim u (lSucc u) (_ => Type u) (Empty u) (Unit u);
Nat : (u : Level) -> Type u :=
  u => W u u (Bool u) (IsFalse u);
zero : (u : Level) -> Nat u :=
  u => sup u u (Bool u) (IsFalse u) (true u) (Empty.elim u u (_ => Nat u));
succ : (u : Level) -> Nat u -> Nat u :=
  u => n => sup u u (Bool u) (IsFalse u) (false u) (_ => n);
Nat.elim : (u : Level) -> (v : Level) -> (P : Nat u -> Type v) -> P (zero u) -> ((n : Nat u) -> P n -> P (succ u n)) -> (n : Nat u) -> P n :=
  u => v => P => h => ih => W.elim u u v (Bool u) (IsFalse u) P
    (Bool.elim u (lMax u v) (i => (f : IsFalse u i -> Nat u) -> ((j : IsFalse u i) -> P (f j)) -> P (sup u u (Bool u) (IsFalse u) i f))
      (f => h' => ?)
      (f => h' => ih (f (star u)) (h' (star u)))
    );